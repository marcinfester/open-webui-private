---
description: 
globs: 
alwaysApply: true
---
---
description: Stały kontekst architektury, standardów i procedur Open WebUI.
globs: []
alwaysApply: true
---

# 0 · **Zasady ogólne developmentu** (General Development Rules)

## Język i komunikacja
- **Język odpowiedzi**: zawsze odpowiadaj po polsku.
- **Język kodu**: cały kod (wraz ze stringami i komentarzami) pisz w języku angielskim.

## Reużycie i analiza kodu (Code Reuse & Analysis)
- **Reuse First**: zanim dodasz nowy komponent lub funkcjonalność, wyszukaj w projekcie istniejące rozwiązania o tej samej lub podobnej nazwie i zachowaniu.
- **Component Discovery**: jeśli znajdziesz pasujący komponent, użyj go zamiast tworzyć nowy.
- **Structure Analysis**: analizuj strukturę folderów i nazewnictwo, by upewnić się, że sugerujesz właściwy moduł.

## Projektowanie funkcji (Function Design)
- **Single Level of Abstraction**: każda funkcja powinna mieć dokładnie jeden poziom abstrakcji.
- **Avoid Mixed Logic**: unikaj mieszania logiki niskiego poziomu (np. operacje na tablicach) z logiką wysokiego poziomu (np. zarządzanie stanem).
- **Functional Programming**: preferuj czyste, funkcyjne podejście:
  - Funkcje powinny być niemutowalne i referencyjnie przezroczyste (referentially transparent).
  - Unikaj efektów ubocznych (side effects).

## Spójność stylu (Style Consistency)
- **Project Conventions**: stosuj się do istniejących w projekcie konwencji:
  - Styl kodu (indentacja, nazewnictwo zmiennych, używane biblioteki).
  - Format plików (ESLint, Prettier itp.).
  - Struktura importów i eksportów.

## Ostrożność przy modyfikacjach (Careful Modifications)
- **Analysis First**: nie zmieniaj istniejących funkcjonalności bez wcześniejszej, wnikliwej analizy.
- **Read Context**: przeczytaj kod, aby zrozumieć kontekst.
- **Step-by-Step**: przed wprowadzeniem zmian opisz krok po kroku swoje wnioski („think step by step").
- **Keep Reasoning**: zachowaj w pamięci argumentację i wnioski („keep the argument and the conclusion in mind").

## Proces myślenia (Thinking Process)
Myśl krok po kroku:
1. **Identify Goal**: zidentyfikuj cel i wymagania.
2. **Check Existing**: sprawdź istniejące implementacje.
3. **Review Documentation**: przejrzyj dołączoną dokumentację.
4. **Plan Solution**: wyprowadź plan rozwiązania, uwzględniając poziom abstrakcji i styl.
5. **Summarize**: na koniec podsumuj swój tok rozumowania.

## Weryfikacja dokumentacji (Documentation Verification)
- **Check Documentation**: zawsze sprawdzaj dołączoną dokumentację (attached documentation) pod kątem wymagań i zgodności przed implementacją nowego rozwiązania.

# 1 · Przegląd systemu
- Open WebUI to pełny stack (SvelteKit + FastAPI) do zarządzania rozmowami z modelami AI.  
- Backend zawiera 24 moduły routerów i 17 modeli danych; frontend korzysta z architektury file-based routing.

# 2 · Stack technologiczny
## Frontend
- **SvelteKit 2.5+**, **TypeScript 5.5+**, **Tailwind CSS 4**.  
- Realtime przez **socket.io-client**; edytory **TipTap** i **CodeMirror**.  
## Backend
- **FastAPI 0.115.7** na **Python 3.11+**, **SQLAlchemy 2**, **Pydantic 2**.  
- Asynchroniczne serwowanie via **uvicorn**; websockety przez **python-socketio**.  
## Bazy danych
- Relacyjne: **PostgreSQL / SQLite + pgvector**.  
- Wektorowe: **ChromaDB, Qdrant, Milvus, Pinecone, Elasticsearch**.  
- Cache opcjonalny: **Redis**.

# 3 · Architektura backendu
- Punkt wejścia: `@backend/main.py` (konfiguracja FastAPI, middleware, socket-io).  
- Modularne routery z podziałem: Core, AI/ML, Content, Management, Admin.  
- Wszystkie handlery używają `async/await`; zadania w tle przez **BackgroundTasks**.

# 4 · Architektura frontendu
- File-based routing w `@src/routes/`.  
- Główne chronione trasy w folderze `(app)/`; globalny layout w `+layout.svelte`.  
- Komponenty modularne w `@src/lib/components/` (chat, workspace, admin, layout).  
- Centralny stan w **Svelte Stores** (`user`, `config`, `chats`, `models`).

# 5 · **Standardy kodowania** (Coding Standards)
- **Język kodu**: cały kod, komentarze i nazwy zmiennych w języku angielskim; tekst UI i18n.  
- **Reuse First**: zanim napiszesz nowy komponent (component) czy router, sprawdź, czy podobny element już istnieje.  
- **Single Responsibility**: każda funkcja lub komponent odpowiada za jedno zadanie.  
- **Functional Style**: preferuj czyste funkcje (pure functions) i unikaj efektów ubocznych.  
- **Typowanie**: pełne adnotacje typów (type hints) w Pythonie i ścisły TypeScript (`"strict": true`).  
- **Async/await** we wszystkich operacjach I/O (FastAPI + SQLAlchemy AsyncEngine)  [oai_citation:11‡docs.sqlalchemy.org](mdc:https:/docs.sqlalchemy.org/en/latest/core/pooling.html?utm_source=chatgpt.com) [oai_citation:12‡docs.sqlalchemy.org](mdc:https:/docs.sqlalchemy.org/en/latest/orm/extensions/asyncio.html?utm_source=chatgpt.com).  
- **Pydantic v2** z `ConfigDict(from_attributes=True)` dla walidacji modeli.  
- Backendowe wstrzykiwanie zależności (dependency injection) przez `Depends`.

# 6 · **Wzorce API** (API Patterns)
- REST + OpenAPI 3.1.  
- Strumieniowanie odpowiedzi (streaming responses) dla endpointów czatu.  
- WebSocket (Socket.io) dla komunikacji w czasie rzeczywistym.  
- Zadania w tle (background tasks) dla ciężkich operacji.  
- Jednolite mapowanie błędów i kody HTTP.

# 7 · **Wzorce bazy danych** (Database Patterns)
- SQLAlchemy ORM async z connection poolingiem i pgbouncer  [oai_citation:13‡docs.sqlalchemy.org](mdc:https:/docs.sqlalchemy.org/en/latest/core/pooling.html?utm_source=chatgpt.com).  
- Migracje schematu przez Alembic.  
- Wektorowe bazy ChromaDB/Qdrant/Milvus/Pinecone/Elasticsearch.  
- Redis jako opcjonalny cache i rate-limit storage.

# 8 · **Testy i observability**
- **pytest 8+** z asynchronicznymi fiksturami; ostrzeżenie *DeprecationWarning* dla sync-test → async-fixture  [oai_citation:14‡docs.pytest.org](mdc:https:/docs.pytest.org/en/stable/changelog.html?utm_source=chatgpt.com).  
- **Vitest** + **Cypress** dla frontendu; E2E w Playwright/Cypress.  
- **OpenTelemetry** (traces, metrics, logs) dla całego stacku  [oai_citation:15‡opentelemetry.io](mdc:https:/opentelemetry.io/docs/languages/python/getting-started/?utm_source=chatgpt.com).

# 9 · **Optymalizacja wydajności** (Performance Optimization)
- **Backend**: async I/O, pooling, Redis cache, zadania w tle.  
- **Frontend**: lazy loading, virtual scrolling, service worker.  
- **Tailwind CSS**: produkcyjny build ograniczający CSS tylko do używanych klas  [oai_citation:16‡tailwindcss.com](mdc:https:/tailwindcss.com/docs/optimizing-for-production?utm_source=chatgpt.com) [oai_citation:17‡tailwindcss.com](mdc:https:/tailwindcss.com/docs/upgrade-guide?utm_source=chatgpt.com).

# 10 · **Bezpieczeństwo** (Security)
- JWT z ustawionym TTL i rotacją.  
- OAuth2 (PKCE) + opcjonalne LDAP-TLS.  
- RBAC, ograniczenia API-keys, rate-limiting.  
- CSP, CSRF, walidacja danych wejściowych.

# 11 · **Rozwiązywanie problemów** (Troubleshooting Context)
Najczęstsze punkty awarii i kontroli:
| Obszar | Kontrola | Narzędzia |
|---|---|---|
| **Auth** | Poprawność JWT / OAuth flow | `/api/auths/verify`, logi backendu |
| **DB** | Connection string, migracje | `alembic revision --autogenerate` |
| **Vector DB** | Widoczność modeli embeddingu | health-check endpoint DB |
| **Storage** | Klucze dostępu / region | `mc ls` (minio), AWS CLI |
| **WebSocket** | Status handshake, wersja Socket.io | DevTools → Network > WS |

# 12 · **Przydatne ścieżki referencyjne**
@backend/routers/auths.py  
@backend/routers/chats.py  
@src/lib/components/chat/MessageInput.svelte  
@src/lib/stores/user.ts